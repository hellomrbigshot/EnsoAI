diff --git a/dist/index.js b/dist/index.js
index 4ba7afcaa6236663bc13fc8a459f04dea7ac36aa..38fb91a0d88511e92df98eae394598ecfe05bee9 100644
--- a/dist/index.js
+++ b/dist/index.js
@@ -1,5 +1,5 @@
 import { NoSuchModelError, LoadAPIKeyError, APICallError } from '@ai-sdk/provider';
-import { spawn } from 'child_process';
+import { spawn, spawnSync } from 'child_process';
 import { randomUUID } from 'crypto';
 import { createRequire } from 'module';
 import { mkdtempSync, writeFileSync, rmSync, readFileSync } from 'fs';
@@ -8,6 +8,40 @@ import { join, dirname } from 'path';
 import { z } from 'zod';
 import { parseProviderOptions, generateId } from '@ai-sdk/provider-utils';
 
+// Windows platform detection for shell mode
+var _isWindows = process.platform === "win32";
+
+// Kill process tree helper
+function killProcessTree(child, signal = 'SIGTERM') {
+  const pid = child.pid;
+  if (!pid) {
+    try { child.kill(signal); } catch {}
+    return;
+  }
+  try {
+    if (_isWindows) {
+      spawnSync('taskkill', ['/pid', String(pid), '/t', '/f'], { stdio: 'ignore' });
+    } else {
+      // Use pgrep to find all descendant processes and kill them
+      try {
+        // Get all child PIDs recursively using pgrep
+        const result = spawnSync('pgrep', ['-P', String(pid)], { encoding: 'utf-8' });
+        if (result.stdout) {
+          const childPids = result.stdout.trim().split('\n').filter(Boolean).map(Number);
+          // Recursively kill children first
+          for (const childPid of childPids) {
+            killProcessTree({ pid: childPid }, signal);
+          }
+        }
+      } catch {}
+      // Kill the main process
+      try {
+        process.kill(pid, signal);
+      } catch {}
+    }
+  } catch {}
+}
+
 // src/codex-cli-provider.ts
 
 // src/logger.ts
@@ -1004,13 +1038,13 @@ var CodexCliLanguageModel = class {
     let usage = createEmptyCodexUsage();
     const finishReason = mapCodexCliFinishReason(void 0);
     const startTime = Date.now();
-    const child = spawn(cmd, args, { env, cwd, stdio: ["pipe", "pipe", "pipe"] });
+    const child = spawn(cmd, args, { env, cwd, stdio: ["pipe", "pipe", "pipe"], shell: _isWindows });
     child.stdin.write(promptText);
     child.stdin.end();
     let onAbort;
     if (options.abortSignal) {
       if (options.abortSignal.aborted) {
-        child.kill("SIGTERM");
+        killProcessTree(child, "SIGTERM");
         if (schemaPath) {
           try {
             const schemaDir = dirname(schemaPath);
@@ -1023,7 +1057,7 @@ var CodexCliLanguageModel = class {
         }
         throw options.abortSignal.reason ?? new Error("Request aborted");
       }
-      onAbort = () => child.kill("SIGTERM");
+      onAbort = () => killProcessTree(child, "SIGTERM");
       options.abortSignal.addEventListener("abort", onAbort, { once: true });
     }
     try {
@@ -1171,7 +1205,7 @@ var CodexCliLanguageModel = class {
     const stream = new ReadableStream({
       start: (controller) => {
         const startTime = Date.now();
-        const child = spawn(cmd, args, { env, cwd, stdio: ["pipe", "pipe", "pipe"] });
+        const child = spawn(cmd, args, { env, cwd, stdio: ["pipe", "pipe", "pipe"], shell: _isWindows });
         child.stdin.write(promptText);
         child.stdin.end();
         controller.enqueue({ type: "stream-start", warnings });
@@ -1261,11 +1295,11 @@ var CodexCliLanguageModel = class {
           }
         };
         const onAbort = () => {
-          child.kill("SIGTERM");
+          killProcessTree(child, "SIGTERM");
         };
         if (options.abortSignal) {
           if (options.abortSignal.aborted) {
-            child.kill("SIGTERM");
+            killProcessTree(child, "SIGTERM");
             cleanupTempFiles();
             controller.error(options.abortSignal.reason ?? new Error("Request aborted"));
             return;
